# K8s Offline Tool 日志与报告系统实现详解

本项目实现了一套高性能、可视化的双轨制日志系统，旨在平衡**安装过程中的实时交互体验**与**安装后的故障追溯需求**。

---

## 1. 核心设计思想

系统采用“**中枢上下文 + 异步渲染**”的设计模式：
*   **中枢上下文 (`NodeContext`)**：每个节点拥有独立的上下文对象，存储当前步骤、状态、执行耗时及日志缓冲区。
*   **实时 TUI (终端 UI)**：基于 `mpb` 库进行高性能刷新，只展示当前正在进行的动态（如进度条、实时速率）。
*   **结构化报告 (`Summary Log`)**：步骤执行完成后，将格式化后的最终状态写入该节点的私有缓冲区，最后统一落盘。

---

## 2. 数据结构：NodeContext

`NodeContext` 是整个系统的核心模型，定义在 `pkg/ui/reporter.go` 中：

```go
type NodeContext struct {
	IP                string
	IsDryRun          bool          // 是否为预检查模式
	LogBuffer         *bytes.Buffer // 私有日志缓冲区，存储格式化后的步骤记录
	CurrentStepStatus string        // 用于 TUI 显示的动态状态（如：🔍 检查中...）
	ResourceProgress  string        // 专门用于存储资源分发的实时百分比/速率
	Mu                sync.Mutex    // 保证多节点并发操作时的线程安全
    // ... 其他字段
}
```

---

## 3. 实时 TUI 刷新机制

### 3.1 动态状态装饰器 (`statusDecorator`)
通过 `mpb` 库的 `decor.Any` 接口实现自定义渲染逻辑。它会实时观察 `NodeContext` 中的变量：

1.  **分发资源时**：如果 `ResourceProgress` 不为空，优先显示资源分发的实时速率（如 `86.29% (296.7/343.8 MB) 6.03 MB/s`）。
2.  **执行普通步骤时**：显示当前步骤名称及动态状态（如 `⏳ [05/12] 配置内核参数: 🚀 正在执行...`）。
3.  **模式自适应**：根据 `IsDryRun` 标志，在结束时动态显示“✔ 预检查完成”或“✔ 安装成功”。

---

## 4. 结构化离线报告实现

安装结束后生成的 `k8s-install-summary.log` 采用了严格的表格化对齐。

### 4.1 CJK 字符对齐方案
在终端和文本文件中，中文字符通常占 2 个半角宽度。传统的 `fmt.Printf("%-30s")` 会导致对齐失效。
**实现逻辑**：
使用 `github.com/mattn/go-runewidth` 库的 `FillRight` 方法：
```go
paddedName := runewidth.FillRight(stepName, 40) // 确保步骤名在显示层级始终占据 40 个宽度
```

### 4.2 步骤日志的单行化
为了避免资源分发时产生的成百上千行进度日志污染报告，系统采取了以下策略：
*   **分发过程**：实时进度仅更新到 `NodeContext.ResourceProgress` 并反馈给 TUI。
*   **落盘记录**：在 `EndStep` 触发时，仅向 `LogBuffer` 写入一行最终的汇总记录（包含步骤名、最终结果、总耗时）。

---

## 5. 日志生成流程

1.  **步骤开始 (`StartStep`)**：更新 `CurrentStep`，将状态置为“🔍 检查中...”。此时**不写入** `LogBuffer`。
2.  **执行过程中**：
    *   普通 Shell 输出：重定向至 `LogBuffer`（可选）。
    *   资源进度：调用 `UpdateResourceProgress`，仅刷新内存，不写文件。
3.  **步骤结束 (`EndStep`)**：
    *   计算该步骤总耗时。
    *   使用 `runewidth` 格式化当前步骤行。
    *   将整行（含前缀、步骤名、对齐的状态图标、耗时）原子化写入 `LogBuffer`。
4.  **最终汇总 (`GenerateFinalReport`)**：
    *   遍历所有节点。
    *   按角色（Master/Worker）进行分类。
    *   将各节点的 `LogBuffer` 完整提取并拼接到最终的报告文件中。

---

## 6. 实现效果示例

### 6.1 TUI 交互界面
```text
📦 Master 节点组 [1/1 运行中, 0 完成]
[192.168.31.150] 45% [========>            ] ⏳ [01/15] 分发离线资源: 🚀 resources.tar.gz 45.12% (155/343MB) 6.2MB/s
```

### 6.2 离线报告文件 (`k8s-install-summary.log`)
```text
[192.168.31.150] ▶ [STEP] 分发离线资源                      ✔ 完成            (58.88s)
[192.168.31.150] ▶ [STEP] 禁用 SELinux                      ✔ 完成 (⏭ 可跳过)  (0s)
[192.168.31.150] ▶ [STEP] 配置 Sysctl 内核参数               ✔ 完成            (27ms)
```

---

## 7. 总结
该日志系统通过“**内存实时状态 + 缓冲区异步落盘**”的架构，既保证了安装过程的高响应感，又提供了一份极其整洁、格式对齐、易于阅读的生产级安装总结报告。
